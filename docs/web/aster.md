% MFront usage in [Code-Aster](http://www.code-aster.org/)
% Helfer Thomas
% October 13, 2014

This document shows how to use `MFront` mechanical behaviour in EDF
[`Code_Aster`](http://www.code-aster.org) finite element solver. It is
extracted from the
[`MFront` tutorial](documents/tutoriel/tutoriel.pdf). A full
description is available in the
[`Code_Aster`](http://www.code-aster.org) reference documentation (see
@code_notice_2014).

Usage of `MFront` in [`Code_Aster`](http://www.code-aster.org) can be
made very easy, once a few things have been clarified. This is
precisely the purpose of this page.

Note that this page is focused on mechanical behaviours. *One can also
use material properties generated with the `python` interface*, the
description of which is out of the scope of this page.

Usage of mechanical behaviours generated by `MFront` is a two step
process:

- Generating the shared library containing the mechanical behaviour
  using `MFront`.
- Declaring the mechanical behaviour in the `COMPORTEMENT` field of
  the `STAT_NON_LINE` function.

In the following, we will consider the case of single mechanical
behaviour implemented in a file called `plasticity.mfront`.

> **A word of caution**
> 
> `MFront` is now part of the `Code_Aster` distribution. **The use of
> another version of `MFront` for generating mechanical behaviours is
> strongly discouraged** as there is no garantee that two versions of
> MFront are binary compatible: combining two versions of `MFront` can
> lead to an error in the best case, crashes of `Code_Aster` in the
> worst case and a wide variety of strange behaviours in between.

> ** `MFront` behaviours officially integrated in `Code_Aster` **
>
> Some mechanical behaviours officially available in `Code_Aster` are
> natively generated with `MFront`. Those may be distinguished by
> their names which are lowercase (e.g. `Iwan`).
> This page only deals with user generated `MFront` mechanical behaviours.

# Overview of the `aster` interface 

The `aster` interface can be used to introduce:

- Small strain mechanical behaviours. Those behaviours can be used
  with the `GDEF_LOG` and `GROT_GDEP` finite strain strategies (see
  @edf_modeles_2013).
- Finite strain mechanical behaviours. Those behaviours must be used
  with the `SIMO_MIEHE` finite strain formulation (see
  @edf_loi_2013). This feature is only available for `Code_Aster`
  version greater than `13.x`.
- Cohesive zone models.

# Generating the shared library

The first step can be done as part of a `Code_Aster` simulation or
before running `Code_Aster`. These two approaches have their
advantages and their drawbacks.

The first one is used in `Code_Aster` verification tests
associated with `MFront` and for various examples delivered with the
code.

In practice, we consider the second approach to be easier and more
flexible.

## Generating the shared library as part of the `Code_Aster` simulation

The instructions for the generation of the shared library are given in
the `.comm` file by an instruction similar to:

~~~~{.python}
os.system("mfront --obuild plasticity.mfront --interface=aster")
~~~~

Such an instruction requires the `os` `python` module to be loaded at
the beginning of the `.comm` file.

The previous instruction calls the `mfront` executable which will:

- generate `C++` sources for the `aster` interface from the
  `plasticity.mfront` file
- build the shared library from the previous `C++` sources.

Those operations are performed in a temporary directory in which the
`Code_Aster` simulation is run. **For the `plasticity.mfront` to be
present in this directory, it must be declared in `astk` as an external
data file (e.g. with type `nom`)**.

The library is generated in the `src` subdirectory. For convenience,
this library is often copied in the current directory and renamed with
an instruction similar to:

~~~~{.python}
os.system("cp src/libAsterBehaviour.so plasticity.so")
~~~~

### Advantages

The advantage of this first approach is that `as_run` automatically
set various environment variables for `mfront` to work.

Moreover, the library is generated in the current directory (or in the
`src` subdirectory if the library is not copied and renamed), which
means that it can directly be found when needed, typically when the
`STAT_NON_LINE` function is called.

### Drawbacks

This first approach however have however serious drawbacks:

- No error messages is thrown if the generation of the `C++` sources
  or the compilation of the shared library fail.
- The user must know *a priori* the name of the generated library:
  Although `libAsterBehaviour.so` is the default and most common name,
  this name can be affected by the use of the `@Material` or the
  `@Library` `mfront` keywords.
- The user must know *a priori* the name of function that implements
  the behaviour. This name is most of the time deduced from the
  behaviour name, as given by `@Behaviour` `mfront` keyword, but it
  can affected by use of the `@Material` keyword.
- The shared library is compiled at each run of the simulation. This
  can be a waste of time (the compilation of an unique behaviour can
  take several seconds).
- It precludes, or at least makes more difficult, the use of advanced
  `MFront` functionalities, such as calling other `MFront` files
  (declaring for example material properties) from the
  `plasticity.mfront` file.

## Second approach: generating the library before launching the simulation

### Usage of `MFront` outside the `Code_Aster` environment

As previously described, `as_run` sets up various environment
variables to enable the use of `mfront` and the use of the shared
libraries generated by `mfront` during the simulation.

To use `MFront` outside of a `Code_Aster` simulation, we have to set an
appropriate environment.

Let `ASTER_ROOT` be an environment variable containing the installation
directory of `Code_Aster` (`as_run` and `astk` are then located in the
`$ASTER_ROOT/bin` directory). In the examples below, the `ASTER_ROOT`
variable is supposed to have been defined by the user. Using the
`bash` shell, this is done by:

~~~~{.sh}
$ export ASTER_ROOT=/home/th202608/codes/aster/13.3.0/install/
~~~~

Of course, the previous instruction must be adapted for your specific
installation.

`MFront` is installed in `$ASTER_ROOT/public/mfront-xxx` where `xxx`
stands for the version of `MFront` delivered with `Code_Aster`.

To use `MFront`, one must set the `PATH` and `LD_LIBRARY_PATH` as
follows:

~~~~{.sh}
$ export PATH=$ASTER_ROOT/public/mfront-xxx/bin:$PATH
$ export LD_LIBRARY_PATH=$ASTER_ROOT/public/mfront-xxx/lib:$LD_LIBRARY_PATH
~~~~

To check that those environments have been properly set, just type:

~~~~{.sh}
$ mfront
MFront::exe: no file name specified and nothing to be done
Usage: mfront [options] [files]
~~~~

This shows that `mfront` has been found and is functional.

### Generation of the shared library

The following instruction will compile the `MFront` behaviour using
the `aster` interface :

~~~~ {.bash}
$ mfront --obuild --interface=aster plasticity.mfront
Treating target : all
The following library has been built :
- libAsterBehaviour.so :  asterplasticity
~~~~~~~~~~~~~~~~~~~

This shows that the `libAsterBehabviour.so` has been generated. It
contains a function called `asterplasticity`. This library is located
in the `src` subdirectory.

### Advantages

This second approach has the following advantages:

- Compilation errors are easier to detect, analyze and correct.
- The mechanical behaviours can be tested with `MTest` before their
  introduction in `Code_Aster`, which is a good pratice.
- All the functionnalities of `MFront` are available.
- The shared library is build only once (i.e. is not rebuilt for each
  simulation run)
- The shared library can be placed in a shared folder, allowing
  various members of a team to use the same mechanical behaviour.

### Drawbacks

The shared library is not in the temporary directory used by `as_run`
to run the simulation, so the user must specify
where it is located. This can be done in various ways:

- The library can be marked as a dependency of the computation in
  `astk` (external data file).
- The absolute path of the library must be given.
- The directory where the shared library is located must be added to
  the `LD_LIBRARY_PATH`.

# Declaration of the call

Starting from an existing input file, two things must be declared:

- a material with appropriate coefficients using the `DEFI_MATERIAU`
  operator.
- a behaviour in the `COMPORTEMENT` field of the mechanical operators
  (`STAT_NON_LINE`, `DYNA_NON_LINE`, `SIMU_POINT_MAT`, ...).

## Call to the `DEFI_MATERIAU`

### Version 12.x

In the `DEFI_MATERIAU` block, one must add for `Code_Aster` version
`12.x`:

~~~~ {.python}
.......=DEFI_MATERIAU( UMAT=_F( LISTE_COEF = (C1,C2,....),),)
~~~~~~~~~~~~~~~~

### Version 13.x

For version greater than `13`, the syntax has evolved:

~~~~ {.python}
.......=DEFI_MATERIAU( MFRONT=_F( LISTE_COEF = (C1,C2,....)),)
~~~~~~~~~~~~~~~~

In both cases, `C1`, ..., `CN` are the material properties declared by the
`MFront` behaviour, **in the same exact order**.

## Definition of the material in the `COMPORTEMENT` field of mechanical operators

In the `COMPORTEMENT` part of the main computation instructions
(`STAT_NON_LINE`, `DYNA_NON_LINE`, `SIMU_POINT_MAT`, ...), the
behaviour has the name `MFRONT`. Here is an example of such
declaration:

### Version 12.x

~~~~ {.python}
COMPORTEMENT=_F ( RELATION    = 'UMAT',
	              LIBRAIRIE   = 'libAsterBehaviour.so',
			      NOM_ROUTINE = 'asterplasticity',
	              NB_VARI     = 19,
			      DEFORMATION = 'GDEF_LOG', )
~~~~~~~~~~~~~~~~

### Version 13.x

~~~~ {.python}
COMPORTEMENT=_F ( RELATION    = 'MFRONT',
	              LIBRAIRIE   = 'libAsterBehaviour.so',
			      NOM_ROUTINE = 'asterplasticity',
			      DEFORMATION = 'GDEF_LOG', )
~~~~~~~~~~~~~~~~

#References

<!-- Local IspellDict: english -->
