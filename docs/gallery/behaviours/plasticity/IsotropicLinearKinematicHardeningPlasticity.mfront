@DSL DefaultDSL;
@Behaviour IsotropicLinearKinematicHardeningPlasticity;
@Author Thomas Helfer;
@Date   14/10/2016;
@Description{
  An explicit implementation of a simple
  isotropic plasticity behaviour.
}

@StateVariable StrainStensor eel;
eel.setGlossaryName("ElasticStrain");
@StateVariable StrainStensor a;

@Parameter young =  70.e9;
young.setGlossaryName("YoungModulus");
@Parameter nu    =   0.34;
nu.setGlossaryName("PoissonRatio");
@Parameter s0    = 300.e6;
s0.setGlossaryName("YieldStress");
@Parameter C     =  10.e9;
C.setEntryName("HardeningSlope");

@PredictionOperator{
  const auto lambda = computeLambda(young,nu);
  const auto mu     = computeMu(young,nu);
  Dt = lambda*Stensor4::IxI()+2*mu*Stensor4::Id();
}

@ProvidesSymmetricTangentOperator;
@Integrator{
  const auto lambda = computeLambda(young,nu);
  const auto mu     = computeMu(young,nu);
  const auto X      = 2*C*a/3;
  eel += deto;
  const auto s      = 2*mu*deviator(eel)-X;
  const auto seq    = sigmaeq(s);
  if(seq-s0>stress{0}){
    const auto n  = (3*s)/(2*seq);
    const auto dp = (seq-s0)/(3*mu+C);
    a   += dp*n;
    eel -= dp*n;
    if(computeTangentOperator_){
      if(smt==CONSISTENTTANGENTOPERATOR){
	Dt = (lambda*Stensor4::IxI()+2*mu*Stensor4::Id()
	      -4*mu*mu*((dp/seq)*(Stensor4::M()-(n^n))+(n^n)/(3*mu+C)));
      } else {
	Dt = lambda*Stensor4::IxI()+2*mu*Stensor4::Id();
      }
    }
  } else {
    if(computeTangentOperator_){
      Dt = lambda*Stensor4::IxI()+2*mu*Stensor4::Id();
    }
  }
  sig = lambda*trace(eel)*Stensor::Id()+2*mu*eel;
}
