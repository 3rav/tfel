/*!
 * \file   MFrontPleiadesModelParserArchitecture1_4.cxx
 * \brief    
 * \author Helfer Thomas
 * \date   10 Nov 2006
 */

#include<iterator>
#include<string>
#include<stdexcept>
#include<sstream>
#include<algorithm>
#include<cctype>
#include<cassert>

#include"TFEL/System/System.hxx"

#include"MFront/ParserUtilities.hxx"
#include"MFront/MFrontHeader.hxx"
#include"MFront/MFrontParserFactory.hxx"
#include"MFront/MFrontPleiadesModelParserArchitecture1.4.hxx"

namespace mfront{

  MFrontPleiadesModelParserArchitecture1_4::MFrontPleiadesModelParserArchitecture1_4(void)
  {
    this->reserveName("period");
    this->reserveName("dt");
    this->reserveName("ptr");
    this->reserveName("ptr2");
    this->reserveName("index");
    this->reserveName("nodes");
    this->reserveName("nbrOfPeriods");
  } // end of MFrontPleiadesModelParserArchitecture1_4::MFrontPleiadesModelParserArchitecture1_4()

  std::string
  MFrontPleiadesModelParserArchitecture1_4::getName(void)
  {
    return "PleiadesModel_1_4";
  } // end of MFrontPleiadesModelParserArchitecture1_4::getName(void)

  std::string
  MFrontPleiadesModelParserArchitecture1_4::getDescription()
  {
    return "this parser is used to define simple material models for pleiades";
  } // end of MFrontPleiadesModelParserArchitecture1_4::getDescription

  void
  MFrontPleiadesModelParserArchitecture1_4::openOutputFiles(void)
  {
    using namespace std;
    using namespace tfel::system;
    // creating directories
    systemCall::mkdir("include");
    systemCall::mkdir("include/Pleiades");
    systemCall::mkdir("include/Pleiades/PMetier");
    systemCall::mkdir("include/Pleiades/PMetier/PModels");
    systemCall::mkdir("src");
    this->headerFile.open(this->headerFileName.c_str());
    if(!this->headerFile){
      string msg("MFrontPleiadesModelParserArchitecture1_4::openOutputFiles : ");
      msg += "unable to open ";
      msg += this->headerFileName;
      msg += " for writing output file.";
      throw(runtime_error(msg));
    }
    this->srcFile.open(this->srcFileName.c_str());
    if(!this->srcFile){
      string msg("MFrontPleiadesModelParserArchitecture1_4::openOutputFiles : ");
      msg += "unable to open ";
      msg += this->srcFileName;
      msg += " for writing output file.";
      throw(runtime_error(msg));
    }
    this->headerFile.exceptions(ios::badbit|ios::failbit);
    this->srcFile.exceptions(ios::badbit|ios::failbit);
  } // end of MFrontPleiadesModelParserArchitecture1_4::openOutputFiles()
  
  void
  MFrontPleiadesModelParserArchitecture1_4::closeOutputFiles(void)
  {
    this->headerFile.close();
    this->srcFile.close();
  } // end of MFrontPleiadesModelParserArchitecture1_4::closeOutputFiles()
  
  void
  MFrontPleiadesModelParserArchitecture1_4::generateOutputFiles(void)
  {
    using namespace std;
    VarContainer::const_iterator p;
    this->hasDefaultConstructor=true;
    if(!this->localParameters.empty()){
      for(p=this->localParameters.begin();
	  (p!=this->localParameters.end())&&(this->hasDefaultConstructor);++p){
	if(this->defaultValues.find(p->name)==this->defaultValues.end()){
	  this->hasDefaultConstructor = false;
	}
      }
    }
    this->writeHeaderFile();
    this->writeSrcFile();
  } // end of MFrontPleiadesModelParserArchitecture1_4::generateOutputFiles(void)

  void
  MFrontPleiadesModelParserArchitecture1_4::writeHeaderFile(void)
  {
    using namespace std;
    VarContainer::const_iterator p;
    StaticVarContainer::const_iterator p2;
    FunctionContainer::const_iterator p3;
    set<string>::iterator p4;
    set<string>::iterator p5;
//     vector<LoadingVariable>::const_iterator p6;
    this->headerFile << "/*!" << endl;
    this->headerFile << "* \\file   " << this->headerFileName  << endl;
    this->headerFile << "* \\brief  " << "this file declares the " 
		     << this->className << " PleiadesModel.\n";
    this->headerFile << "*         File generated by ";
    this->headerFile << MFrontHeader::getVersionName() << " ";
    this->headerFile << "version " << MFrontHeader::getVersionNumber();
    this->headerFile << endl;
    if(!this->authorName.empty()){
      this->headerFile << "* \\author " << this->authorName << endl;
    }
    if(!this->date.empty()){
      this->headerFile << "* \\date   " << this->date       << endl;
    }
    if(!this->description.empty()){
      this->headerFile << this->description << endl;
    }
    this->headerFile << " */\n\n";

    this->headerFile << "#ifndef _PLEIADES_" 
		     << makeUpperCase(this->className)
		     << "_HH\n";
    this->headerFile << "#define _PLEIADES_"
		     << makeUpperCase(this->className)
		     << "_HH\n\n";

    this->headerFile << "#include<string>\n\n";
    this->headerFile << "#include\"Pleiades/PMetier/IncPMetier.hh\"\n";
    this->headerFile << "#include\"Pleiades/PMetier/PModels/MEDModel.hh\"\n\n";
    if(!this->includes.empty()){
      this->headerFile << this->includes << endl << endl;
    }
    writeExportDirectives(this->headerFile);
    this->headerFile << "namespace Pleiades\n{\n";
    this->headerFile << "namespace PMetier\n{\n";
    this->headerFile << "namespace PModels\n{\n\n";
    this->headerFile << "struct MFRONT_SHAREDOBJ " << this->className << endl;
    this->headerFile << ": public IModel,\n";
    this->headerFile << "public MEDModel\n";
    this->headerFile << "{\n\n";
    if(!this->localParameters.empty()){
      this->headerFile << "//! Constructor to initialize local parameters\n";
      this->headerFile << this->className
		       << "(const Pleiades::PMetier::IArgumentMetier&);\n\n";
    }
    if(this->hasDefaultConstructor){
      this->headerFile << "//! Default constructor\n";
      this->headerFile << this->className << "();\n\n";
    }
    this->headerFile << "bool\n"
		     << "initializeOutput(const Pleiades::PMetier::IArgumentMetier&);\n\n";
    this->headerFile << "bool\n"
		     << "initializeInput(const Pleiades::PMetier::IArgumentMetier&);\n\n";
    this->headerFile << "bool\n"
		     << "initializeParameters(const Pleiades::PMetier::IArgumentMetier&);\n\n";
    this->headerFile << "bool\n"
		     << "initialize(const Pleiades::PMetier::IArgumentMetier&);\n\n";
    this->headerFile << "bool\n"
		     << "execute(void);\n\n";
    this->headerFile << "void\n"
		     << "executeInitialPostProcessingTasks(const bool);\n\n";
    this->headerFile << "void\n"
		     << "executePostProcessingTasks(const bool);\n\n";
    this->headerFile << "private:\n\n";
    this->headerFile << "typedef double real;\n";
    this->headerFile << "typedef std::string string;\n";
    this->headerFile << "typedef Pleiades::PUtilitaires::TabString TabString;\n";
    this->headerFile << "typedef Pleiades::PUtilitaires::TabDouble TabDouble;\n";
    this->headerFile << "typedef Pleiades::PMetier::PField::PtrIFieldDouble PleiadesField;\n\n";
    // Disable copy constructor and assignement operator
    this->headerFile << "//! Copy constructor (disabled)\n";
    this->headerFile << this->className << "(const " 
		     << this->className << "&);\n\n";
    this->headerFile << "//! Assignement operator (disabled)\n";
    this->headerFile << this->className << "&\n"
		     << "operator=(const " 
		     << this->className << "&);\n\n";
    // Treat functions
    for(p3=this->functions.begin();p3!=this->functions.end();++p3){
      if(p3->modifiedVariables.size()==0){
	string msg("MFrontPleiadesModelParserArchitecture1_4::writeHeaderFile : ");
	msg+="function " + p3->name + " does not modify any variable (internal error, this shall have been verified long ago).";
	throw(runtime_error(msg));
      }
      if(this->debugMode){
	this->headerFile << "#line " << p3->line << " \"" 
			 << this->fileName << "\"\n";
      }
      if(p3->modifiedVariables.size()==1){
	this->headerFile << "inline double\n";
	this->headerFile << p3->name << "(";
      } else {
	this->headerFile << "inline\n";
	this->headerFile << "void\n";
	this->headerFile << p3->name << "(";
	for(p4=p3->modifiedVariables.begin();p4!=p3->modifiedVariables.end();){
	  this->headerFile << "double&";
	  if((++p4)!=p3->modifiedVariables.end()){
	    this->headerFile << ",";
	  }
	}
      }
      if((p3->usedVariables.size()==0)&&(!p3->useTimeIncrement)){
	if(p3->modifiedVariables.size()==1){
	  this->headerFile << "void";
	}
      } else {
	if(p3->modifiedVariables.size()!=1){
	  this->headerFile << ",";
	}
	for(p4=p3->usedVariables.begin();p4!=p3->usedVariables.end();){
	  this->headerFile << "const double";
	  if((++p4)!=p3->usedVariables.end()){
	    this->headerFile << ",";
	  }
	}
	if(p3->useTimeIncrement){
	  if(p3->usedVariables.size()!=0){
	    this->headerFile << ",";
	  }
	  this->headerFile << "const double";
	}
      }
      this->headerFile << ");\n\n";
    }

    if(!this->staticVars.empty()){
      for(p2=this->staticVars.begin();p2!=this->staticVars.end();++p2){
	if(this->debugMode){
	  this->headerFile << "#line " << p2->lineNumber << " \"" 
			   << this->fileName << "\"\n";
	}
	this->headerFile << "static const " << p2->type << " " << p2->name << ";" << endl;
      }
      this->headerFile << endl;
    }
    for(p=this->outputs.begin();p!=this->outputs.end();++p){
      if(this->debugMode){
	this->headerFile << "#line " << p->lineNumber << " \"" 
			 << this->fileName << "\"\n";
      }
      this->headerFile << "PleiadesField ple" << p->name << ";\n\n";
    }
    this->headerFile << endl;
    for(p=this->inputs.begin();p!=this->inputs.end();++p){
      if(this->debugMode){
	this->headerFile << "#line " << p->lineNumber << " \"" 
			 << this->fileName << "\"\n";
      }
      this->headerFile << "PleiadesField ple" << p->name << ";\n\n";
    }
    this->headerFile << endl;
    for(p=this->globalParameters.begin();p!=this->globalParameters.end();++p){
      if(this->debugMode){
	this->headerFile << "#line " << p->lineNumber << " \"" 
			 << this->fileName << "\"\n";
      }
      this->headerFile << p->type << " " << p->name << ";\n\n";
    }
    for(p=this->constantMaterialProperties.begin();p!=this->constantMaterialProperties.end();++p){
      if(this->debugMode){
	this->headerFile << "#line " << p->lineNumber << " \"" 
			 << this->fileName << "\"\n";
      }
      this->headerFile << p->type << " " << p->name << ";\n\n";
    }
    for(p=this->localParameters.begin();p!=this->localParameters.end();++p){
      if(this->debugMode){
	this->headerFile << "#line " << p->lineNumber << " \"" 
			 << this->fileName << "\"\n";
      }
      this->headerFile << p->type << " " << p->name << ";\n\n";
    }
    this->headerFile << endl;
    this->headerFile << "unsigned short period;\n";
    this->headerFile << "unsigned short nbrOfPeriods;\n\n";
    this->headerFile << "}; // end of class " << this->className << endl << endl;
    this->headerFile << "} // end of namespace PModels\n\n";
    this->headerFile << "} // end of namespace PMetier\n\n";
    this->headerFile << "} // end of namespace Pleiades\n\n";
    this->headerFile << "#endif /* _PLEIADES_"
		     << makeUpperCase(this->className)
		     << "_HH */\n";
  } // end of MFrontPleiadesModelParserArchitecture1_4::writeHeaderFile(void)

  std::string
  MFrontPleiadesModelParserArchitecture1_4::getGenTypeMethod(const std::string& type) const
  {
    using namespace std;
    if((type=="double")||(type=="real")){
      return "getDouble";
    } else if(type=="string"){
      return "getString";
    } else if(type=="TabString"){
      return "getTabString";
    } else if(type=="TabDouble"){
      return "getTabDouble";
    } else if(type=="TabTabDouble"){
      return "getTabTabDouble";
    } else {
      string msg("MFrontPleiadesModelParserArchitecture1_4::getGenTypeMethod : ");
      msg += "no method associated with type " + type;
      throw(runtime_error(msg));
    }
    return "";
  } // end of MFrontPleiadesModelParserArchitecture1_4::getGenTypeMethod

  void
  MFrontPleiadesModelParserArchitecture1_4::writeSrcFile(void)
  {
    using namespace std;
    map<string,vector<Function> > mfunctions;
    map<string,vector<Function> > mfunctionsII;
    set<string> sdomains;
    set<string> sdomainsParameters;
    set<string> usedVariables;
    set<string> modifiedVariables;
    VarContainer::const_iterator p;
    map<string,string>::const_iterator p2;
    map<string,double>::const_iterator p3;
    map<string,string>::const_iterator p4;
    map<string,unsigned short>::const_iterator p5;
    StaticVarContainer::const_iterator p10;
    FunctionContainer::const_iterator p11;
    set<string>::const_iterator p12;
    std::map<std::string,std::vector<Function> >::iterator p13;
    std::vector<Function>::iterator p14;
    set<string>::const_iterator p15;
    set<string>::const_iterator p16;
//     vector<LoadingVariable>::const_iterator p17;
    set<string>::size_type nbr;
    unsigned short j;
    bool found;
    this->srcFile << "/*!" << endl;
    this->srcFile << "* \\file   " << this->srcFileName  << endl;
    this->srcFile << "* \\brief  " << "this file implements the " 
		  << this->className << " PleiadesModel.\n";
    this->srcFile << "*         File generated by ";
    this->srcFile << MFrontHeader::getVersionName() << " ";
    this->srcFile << "version " << MFrontHeader::getVersionNumber();
    this->srcFile << endl;
    if(!this->authorName.empty()){
      this->srcFile << "* \\author " << this->authorName << endl;
    }
    if(!this->date.empty()){
      this->srcFile << "* \\date   " << this->date       << endl;
    }
    this->srcFile << " */\n\n";
    this->srcFile << "#include<iostream>\n";
    this->srcFile << "#include<cmath>\n\n";
    this->srcFile << "#include\"Pleiades/PMetier/pglossaire.hh\"\n";
    this->srcFile << "#include\"Pleiades/PExamplars/ClassProxy.hh\"\n";
    this->srcFile << "#include\"Pleiades/PMetier/PModels/" 
		  << this->className << "-pleiades.hh\"\n\n";
    this->srcFile << "namespace Pleiades\n{\n";
    this->srcFile << "namespace PMetier\n{\n";
    this->srcFile << "namespace PModels\n{\n\n";
    // static variables
    if(!this->staticVars.empty()){
      for(p10=this->staticVars.begin();p10!=this->staticVars.end();++p10){
	if(this->debugMode){
	  this->srcFile << "#line " << p10->lineNumber << " \"" 
			<< this->fileName << "\"\n";
	}
	if(p10->type=="short"){
	  this->srcFile << "const short " << this->className << "::" << p10->name 
			<< " = " << static_cast<short>(p10->value) << ";" << endl;
	} else if(p10->type=="ushort"){
	  this->srcFile << "const unsigned short " << this->className << "::" << p10->name 
			<< " = " << static_cast<unsigned short>(p10->value) << ";" << endl;
	} else if(p10->type=="int"){
	  this->srcFile << "const int " << this->className << "::" << p10->name 
			<< " = " << static_cast<int>(p10->value) << ";" << endl;
	} else if(p10->type=="uint"){
	  this->srcFile << "const unsigned int " << this->className << "::" << p10->name 
			<< " = " << static_cast<unsigned int>(p10->value) << ";" << endl;
	} else if(p10->type=="long"){
	  this->srcFile << "const long " << this->className << "::" << p10->name 
			<< " = " << static_cast<long>(p10->value) << ";" << endl;
	} else if(p10->type=="ulong"){
	  this->srcFile << "const unsigned long " << this->className << "::" << p10->name 
			<< " = " << static_cast<unsigned long>(p10->value) << ";" << endl;
	} else if(p10->type=="float"){
	  this->srcFile << "const float " << this->className << "::" << p10->name 
			<< " = " << static_cast<float>(p10->value) << ";" << endl;
	} else if((p10->type=="double")||(p10->type=="real")){
	  this->srcFile << "const double " << this->className << "::" << p10->name 
			<< " = " << static_cast<double>(p10->value) << ";" << endl;
	} else if(p10->type=="ldouble"){
	  this->srcFile << "const long double " << this->className << "::" << p10->name 
			<< " = " << static_cast<long double>(p10->value) << ";" << endl;
	} else {
	  string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	  msg += "type " + p10->type + " is not a supported type for a static variable. ";
	  msg += "Supported types are short, ushort, int, uint, long, ulong,";
	  msg += "float, double, real and ldouble.\n";
	  msg += "Error at line " + toString(p10->lineNumber);
	  throw(runtime_error(msg));
	}
      }
      this->srcFile << endl;
    }
    // Constructors
    if(this->hasDefaultConstructor){
      this->srcFile << this->className << "::" 
		    << this->className << "()\n{\n";
      for(p=this->localParameters.begin();p!=this->localParameters.end();++p){
	string name;
	if((p4=this->glossaryNames.find(p->name))!=this->glossaryNames.end()){
	  name = "GlossaireParam::" + p4->second;
	} else if((p4=this->entryNames.find(p->name))!=this->entryNames.end()){
	  name = "\""+p4->second+"\"";
	} else {
	  name = "\""+p->name+"\"";
	}
	p4=this->defaultValues.find(p->name);
	assert(p4!=this->defaultValues.end());
	this->writeAssignDefaultValue(p,p4);
      }
      this->srcFile << "} // end of " 
		    << this->className << "::" 
		    << this->className <<"\n\n";
    }
    if(!this->localParameters.empty()){
      this->srcFile << "//! Constructor to initialize local parameters\n";
      this->srcFile << this->className << "::" 
		    << this->className 
		    << "(const Pleiades::PMetier::IArgumentMetier& arg)\n{\n";
      this->srcFile << "using namespace std;\n";
      this->srcFile << "using namespace Pleiades::PUtilitaires;\n";
      this->srcFile << "using namespace Pleiades::PExceptions;\n";
      for(p=this->localParameters.begin();p!=this->localParameters.end();++p){
	string name;
	if((p4=this->glossaryNames.find(p->name))!=this->glossaryNames.end()){
	  name = "GlossaireParam::" + p4->second;
	} else if((p4=this->entryNames.find(p->name))!=this->entryNames.end()){
	  name = "\""+p4->second+"\"";
	} else {
	  name = "\""+p->name+"\"";
	}
	this->srcFile << "if(!arg.contains(" << name << ")){\n";
	if((p4=this->defaultValues.find(p->name))!=this->defaultValues.end()){
	  this->writeAssignDefaultValue(p,p4);
	  this->srcFile << "} else {\n";
	} else {
	  this->srcFile << "string msg(\"" << className << "::" << className << " : \");\n";
	  this->srcFile << "msg += \"can't initialize parameter " << p->name << "\";\n";
	  this->srcFile << "throw(PleiadesError(msg));\n";
	  this->srcFile << "} else {\n";
	}
	this->srcFile << "this->" << p->name << " = arg[" << name << "]." 
		      << this->getGenTypeMethod(p->type) << "();\n";
	this->srcFile << "}\n";
      }
      this->srcFile <<"} // end of "
		    << this->className << "::" 
		    << this->className <<"\n\n";
    }
    // Functions
    for(p11=this->functions.begin();p11!=this->functions.end();++p11){
      if(p11->modifiedVariables.size()==0){
	string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	msg+="function " + p11->name + " does not modify any variable (internal error, this shall have been verified long ago).";
	throw(runtime_error(msg));
      }
      if(this->debugMode){
	this->srcFile << "#line " << p11->line << " \"" 
		      << this->fileName << "\"\n";
      }
      if(p11->modifiedVariables.size()==1){
	this->srcFile << "double\n";
	this->srcFile << this->className << "::" << p11->name << "(";
      } else {
	this->srcFile << "void\n";
	this->srcFile << this->className << "::" << p11->name << "(";
	for(p12=p11->modifiedVariables.begin();p12!=p11->modifiedVariables.end();){
	  this->srcFile << "double& " << *p12;
	  if((++p12)!=p11->modifiedVariables.end()){
	    this->srcFile << ",";
	  }
	}
      }
      if((p11->usedVariables.size()==0)&&(p11->useTimeIncrement)){
	if(p11->modifiedVariables.size()==1){
	  this->srcFile << "void";
	}
      } else {
	if(p11->modifiedVariables.size()!=1){
	  this->srcFile << ",";
	}
	for(p12=p11->usedVariables.begin();p12!=p11->usedVariables.end();){
	  this->srcFile << "const double " << *p12;
	  if((++p12)!=p11->usedVariables.end()){
	    this->srcFile << ",";
	  }
	}
	if(p11->useTimeIncrement){
	  if(p11->usedVariables.size()!=0){
	    this->srcFile << ",";
	  }
	  this->srcFile << "const double dt";
	}
      }
      this->srcFile << ")\n";
      this->srcFile << "{\n";
      this->srcFile << "using namespace std;\n";
      writeMaterialLaws("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile",
			this->srcFile,this->materialLaws);		      
      if(p11->modifiedVariables.size()==1){
	this->srcFile << "double " << *(p11->modifiedVariables.begin()) << ";\n";
      }
      this->srcFile << p11->body;
      if(p11->modifiedVariables.size()==1){
	this->srcFile << "return " << *(p11->modifiedVariables.begin()) << ";\n";
      }
      this->srcFile << "} // end of " << this->className << "::" << p11->name << "\n\n";
    }
    // initializeOutput
    this->srcFile << "bool\n"
		  << this->className
		  << "::initializeOutput(const Pleiades::PMetier::IArgumentMetier& arg)";
    this->srcFile << "{\n";
    this->srcFile << "using namespace std;\n";
    this->srcFile << "using namespace Pleiades::PUtilitaires;\n";
    this->srcFile << "using namespace Pleiades::PExceptions;\n";
    this->srcFile << "using namespace Pleiades::PMetier::PGlossaire;\n";
    for(p=this->outputs.begin();p!=this->outputs.end();++p){
      string name;
      if((p2=this->glossaryNames.find(p->name))!=this->glossaryNames.end()){
	name = "GlossaireField::"+p2->second;
      } else if((p2=this->entryNames.find(p->name))!=this->entryNames.end()){
	name = "\""+p2->second+"\"";
      } else {
	name = "\""+p->name+"\"";
      }
      this->srcFile << "if(!this->initializeOutputIFieldDouble(arg," << name;
      this->srcFile << ",\nthis->ple" << p->name << ",\"FieldMedDouble\",";
      if((p3=this->initialValues.find(p->name))!=this->initialValues.end()){
	this->srcFile << p3->second;
      } else {
	this->srcFile << "0.";
      }
      this->srcFile << ")){\n";
      this->srcFile << "string msg(\"" << this->className << "::initializeOutput : \");\n";
      this->srcFile << "msg += \"can't initialize output field " << p->name << "\";\n";
      this->srcFile << "throw(PleiadesError(msg));\n";
      this->srcFile << "}\n";
    }
    if(!this->outputs.empty()){
      this->srcFile << "MEDModel::initializeMEDModel(arg,this->ple"
		    << this->outputs.front().name <<"->getMesh());\n";
    } else {
      string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : no output field (FIXE ME!!!!)");
      throw(runtime_error(msg));
    }
    if(!this->initializeOutput.empty()){
      this->srcFile << this->initializeOutput;
    }
    this->srcFile << "return true;\n";
    this->srcFile << "} // end of " << this->className << "::initializeOutput \n\n";
    // initializeInput
    this->srcFile << "bool\n"
		  << this->className 
		  << "::initializeInput(const Pleiades::PMetier::IArgumentMetier& arg)";
    this->srcFile << "{\n";
    this->srcFile << "using namespace std;\n";
    this->srcFile << "using namespace Pleiades::PUtilitaires;\n";
    this->srcFile << "using namespace Pleiades::PExceptions;\n";
    this->srcFile << "using namespace Pleiades::PMetier::PGlossaire;\n";
    for(p=this->inputs.begin();p!=this->inputs.end();++p){
      string name;
      if((p2=this->glossaryNames.find(p->name))!=this->glossaryNames.end()){
	name = "GlossaireField::"+p2->second;
      } else if((p2=this->entryNames.find(p->name))!=this->entryNames.end()){
	name = "\""+p2->second+"\"";
      } else {
	name = "\""+p->name+"\"";
      }
      this->srcFile << "if(!this->initializeInputIFieldDouble(this->ple"
		    << p->name << "," << name;
      this->srcFile << ",\"FieldMedDouble\",arg)){\n";
      this->srcFile << "string msg(\"" << this->className << "::initializeInput : \");\n";
      this->srcFile << "msg += \"can't initialize input field " << p->name << "\";\n";
      this->srcFile << "throw(PleiadesError(msg));\n";
      this->srcFile << "}\n";
    }
    this->srcFile << endl;
    if(!this->initializeInput.empty()){
      this->srcFile << this->initializeInput;
      this->srcFile << endl;
    }
    this->srcFile << "return true;\n";
    this->srcFile << "} // end of " << this->className << "::initializeInput\n\n";
    // initializeParamaters
    this->srcFile << "bool\n"
		  << this->className 
		  << "::initializeParameters(const Pleiades::PMetier::IArgumentMetier& arg)";
    this->srcFile << "{\n";
    this->srcFile << "using namespace std;\n";
    this->srcFile << "using namespace Pleiades::PUtilitaires;\n";
    this->srcFile << "using namespace Pleiades::PExceptions;\n";
    this->srcFile << "using namespace Pleiades::PMetier::PGlossaire;\n";
    for(p=this->globalParameters.begin();p!=this->globalParameters.end();++p){
      string name;
      if((p4=this->glossaryNames.find(p->name))!=this->glossaryNames.end()){
	name = "GlossaireParam::" + p4->second;
      } else if((p4=this->entryNames.find(p->name))!=this->entryNames.end()){
	name = "\""+p4->second+"\"";
      } else {
	name = "\""+p->name+"\"";
      }
      this->srcFile << "if(!arg.contains(" << name << ")){\n";
      if((p4=this->defaultValues.find(p->name))!=this->defaultValues.end()){
	this->srcFile << "this->" << p->name << " = " << p4->second << ";" << endl;
	this->srcFile << "} else {\n";
      } else {
	this->srcFile << "string msg(\"" << this->className << "::initializeParameters : \");\n";
	this->srcFile << "msg += \"can't initialize parameter '" << p->name << "' using '\";\n";
	this->srcFile << "msg += " << name << ";\n";
	this->srcFile << "msg += '\\'';\n";
	this->srcFile << "throw(PleiadesError(msg));\n";
	this->srcFile << "} else {\n";
      }
      this->srcFile << "this->" << p->name << " = arg[" << name << "]." 
		    << this->getGenTypeMethod(p->type) << "();\n";
      this->srcFile << "}\n";
    }
    for(p=this->constantMaterialProperties.begin();p!=this->constantMaterialProperties.end();++p){
      string name;
      if((p4=this->glossaryNames.find(p->name))!=this->glossaryNames.end()){
	name = '"'+this->className+".\"+GlossaireParam::" + p4->second;
      } else if((p4=this->entryNames.find(p->name))!=this->entryNames.end()){
	name = "\""+this->className+"."+p4->second+"\"";
      } else {
	name = "\""+this->className+"."+p->name+"\"";
      }
      this->srcFile << "if(!arg.contains(" << name << ")){\n";
      this->srcFile << "string msg(\"" << this->className << "::initializeParameters : \");\n";
      this->srcFile << "msg += \"can't initialize constant material property  '"
		    << p->name << "' using '\";\n";
      this->srcFile << "msg += " << name << ";\n";
      this->srcFile << "msg += '\\'';\n";
      this->srcFile << "throw(PleiadesError(msg));\n";
      this->srcFile << "} else {\n";
      this->srcFile << "this->" << p->name << " = arg[" << name << "]." 
		    << this->getGenTypeMethod(p->type) << "();\n";
      this->srcFile << "}\n";
    }
//     for(p17=this->loadingVariables.begin();p17!=this->loadingVariables.end();++p17){
//       string entryName;
//       if((p4=this->entryNames.find(p17->name))!=this->entryNames.end()){
// 	entryName = p4->second+"Evolution";
//       } else {
// 	entryName = p17->name+"Evolution";
//       }
//       this->srcFile << "if(!arg.contains(\"" << entryName << "\")){\n";
//       this->srcFile << "string msg(\"" << this->className << "::initializeParameters : \");\n";
//       this->srcFile << "msg += \"can't initialize loading variable " << p17->name << "\";\n";
//       this->srcFile << "throw(PleiadesError(msg));\n";
//       this->srcFile << "} else {\n";
//       this->srcFile << "this->" << p17->tabName << " = arg[\"" << entryName << "\"]." 
// 		    <<  "getTabDouble();\n";
//       this->srcFile << "}\n";
//     }
    this->srcFile << "if(!arg.contains(\"ListeTempsReel\")){\n";
    this->srcFile << "string msg(\"" << this->className << "::initializeParameters : \");\n";
    this->srcFile << "msg += \"internal error (can't find list of times).\";\n";
    this->srcFile << "throw(PleiadesError(msg));\n}\n";
    this->srcFile << "this->nbrOfPeriods = static_cast<unsigned short>(arg[\"ListeTempsReel\"].getTabDouble().getTaille())-1;\n";
    if(!this->initializeParameters.empty()){
      this->srcFile << "// initialize parameters\n";
      this->srcFile << this->initializeParameters;
      this->srcFile << endl;
    }
    this->srcFile << "return true;\n";
    this->srcFile << "} // end of " << this->className << "::initializeParameters\n\n";
    // initialize
    this->srcFile << "bool\n"
		  << this->className 
		  << "::initialize(const Pleiades::PMetier::IArgumentMetier& arg)";
    this->srcFile << "{\n";
    this->srcFile << "this->initializeOutput(arg);\n";
    this->srcFile << "this->initializeInput(arg);\n";
    this->srcFile << "this->initializeParameters(arg);\n";
    this->srcFile << "return true;\n";
    this->srcFile << "} // end of " << this->className << "::initialize\n\n";
    // execute
    this->srcFile << "bool\n"
		  << this->className
		  << "::execute(void){\n";
    this->srcFile << "using namespace std;\n";
    this->srcFile << "using namespace Pleiades::PUtilitaires;\n";
    this->srcFile << "using namespace Pleiades::PExceptions;\n";
    this->srcFile << "using namespace Pleiades::PMetier::PTime;\n\n";
    this->srcFile << "typedef MEDMEM::FIELD<double>* MEDFieldPtr;\n";
    this->srcFile << "typedef MEDMEM::FIELD<double>& MEDField;\n\n";
    for(p=this->outputs.begin();p!=this->outputs.end();++p){
      this->srcFile << "MEDField " << p->name 
		    << " = *(static_cast<MEDFieldPtr>(this->ple" << p->name << "->getMed()));\n";
      if((p5=this->depths.find(p->name))!=this->depths.end()){
	for(j=1;j<=p5->second;++j){
	  ostringstream converter;
	  converter << j;
	  string varName = p->name+"_"+converter.str();
	  this->srcFile << "MEDField " << varName 
			<< " = *(static_cast<MEDFieldPtr>(this->ple" 
			<< p->name << "->getFieldPreceding("<< j <<")->getMed()));\n";
	}
      }
    }
    for(p=this->inputs.begin();p!=this->inputs.end();++p){
      this->srcFile << "MEDField " << p->name 
		    << " = *(static_cast<MEDFieldPtr>(this->ple" << p->name << "->getMed()));\n";
      if((p5=this->depths.find(p->name))!=this->depths.end()){
	for(j=1;j<=p5->second;++j){
	  this->srcFile << "MEDField " << p->name << "_" << j
			<< " = *(static_cast<MEDFieldPtr>(this->ple" 
			<< p->name << "->getFieldPreceding("<< j <<")->getMed()));\n";
	}
      }
    }
    this->srcFile << "this->period = static_cast<unsigned short>(ITime::GlobalTime->get(\"position\"));\n";
    this->srcFile << "const double t  = ITime::GlobalTime->get(\"time\");\n";
    this->srcFile << "const double dt = ITime::GlobalTime->get(\"time increment\");\n";
    this->srcFile << "static_cast<void>(t);  // suppress unused variable warning\n";
    this->srcFile << "static_cast<void>(dt); // suppress unused variable warning\n\n";
//     for(p17=this->loadingVariables.begin();p17!=this->loadingVariables.end();++p17){
//       this->srcFile << "const double " << p17->name << " = this->" 
// 		    << p17->tabName << "[period];\n";
//       for(j=1;j!=p17->depth+1;++j){
// 	this->srcFile << "const double " << p17->name << "_" << j << " = this->" 
// 		      << p17->tabName << "[period-" << j << "];\n";
//       }
//     }
    this->srcFile << "cout << \"***" << this->className 
		  << "::execute (period \" << period << \"/\" << this->nbrOfPeriods << \")\\n\";\n\n";

    // calling functions
    // we first sort functions by domains
    for(p11=this->functions.begin();p11!=this->functions.end();++p11){
      if(p11->domains.empty()){
	if(!this->domains.empty()){
	  // function domains are defined though the model's
	  // domains
	  sdomains.insert(this->domains.begin(),this->domains.end());
	  for(p16=this->domains.begin();p16!=this->domains.end();++p16){
	    if((p13=mfunctions.find(*p16))==mfunctions.end()){
	      vector<Function> tmp;
	      tmp.push_back(*p11);
	      mfunctions.insert(make_pair(*p16,tmp));
	    } else {
	      p13->second.push_back(*p11);
	    }
	  }
	} else {
	  string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	  msg += "function "+p11->name+" has no domain and no global is domain defined";
	  throw(runtime_error(msg));
	}
      } else {
	// function domains are explicitly named
	for(p12=p11->domains.begin();p12!=p11->domains.end();++p12){
	  sdomains.insert(*p12);
	  if((p13=mfunctions.find(*p12))==mfunctions.end()){
	    vector<Function> tmp;
	    tmp.push_back(*p11);
	    mfunctions.insert(make_pair(*p12,tmp));
	  } else {
	    p13->second.push_back(*p11);
	  }
	}
      }
    }
    if((!mfunctions.empty())||(!mfunctionsII.empty())){
      this->srcFile << "map<string,vector<int> >::iterator ptr;\n";
      this->srcFile << "vector<int>::const_iterator ptr2;\n";
    }
    // we now declare a nodes set on each domain defined through a
    // string parameter or explicitely named
    nbr = 0u;
    for(p12=sdomainsParameters.begin();p12!=sdomainsParameters.end();++p12){
      found = false;
      p = this->localParameters.begin();
      while((p!=this->localParameters.end())&&(!found)){
	if(p->name==*p12){
	  found = true;
	} else {
	  ++p;
	}
      }
      if(!found){
	p = this->globalParameters.begin();
	while((p!=this->globalParameters.end())&&(!found)){
	  if(p->name==*p12){
	    found = true;
	  } else {
	    ++p;
	  }
	}
      }
      if(!found){
	string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	msg += "internal error while treating parameter "+*p12;
	msg += " (no local nor gloabal parameter associated)";
	throw(runtime_error(msg));
      }
      if(p->type=="string"){
	this->srcFile << "ptr = this->nodesOfZones.find(this->" << *p12<< ");\n";
	this->srcFile << "if(ptr==this->nodesOfZones.end()){\n";
	this->srcFile << "string msg(\"" << this->className << "::execute : \");\n";
	this->srcFile << "msg += \"internal error (no group named \" + this->"
		      << *p12 << " + \" defined).\";\n";
	this->srcFile << "throw(PleiadesError(msg));\n";
	this->srcFile << "}\n";
	this->srcFile << "const vector<int>& nodes" << nbr << "= ptr->second;\n";
	++nbr;
      }
    }
    for(p12=sdomains.begin();p12!=sdomains.end();++p12,++nbr){
      this->srcFile << "ptr = this->nodesOfZones.find(\"" << *p12<< "\");\n";
      this->srcFile << "if(ptr==this->nodesOfZones.end()){\n";
      this->srcFile << "string msg(\"" << this->className << "::execute : \");\n";
      this->srcFile << "msg += \"internal error (no group named "<< *p12 << " defined).\";\n";
      this->srcFile << "throw(PleiadesError(msg));\n";
      this->srcFile << "}\n";
      this->srcFile << "const vector<int>& nodes" << nbr << "= ptr->second;\n";
    }
    // Treating functions whose domains are given by parameters
    nbr = 0u;
    for(p12=sdomainsParameters.begin();p12!=sdomainsParameters.end();++p12){
      found = false;
      p = this->localParameters.begin();
      while((p!=this->localParameters.end())&&(!found)){
	if(p->name==*p12){
	  found = true;
	} else {
	  ++p;
	}
      }
      if(!found){
	p = this->globalParameters.begin();
	while((p!=this->globalParameters.end())&&(!found)){
	  if(p->name==*p12){
	    found = true;
	  } else {
	    ++p;
	  }
	}
      }
      if(!found){
	string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	msg += "internal error while treating parameter "+*p12;
	msg += " (no local nor gloabal parameter associated)";
	throw(runtime_error(msg));
      }
      if(p->type=="string"){
	this->srcFile << "// Calling functions whose domain is defined through parameter "
		      << *p12 << endl;
	this->srcFile << "for(ptr2=n" << nbr << ".begin();";
	this->srcFile << "ptr2!=n" << nbr << ".end();++ptr2){\n";
	p13 = mfunctionsII.find(*p12);
	if(p13==mfunctionsII.end()){
	  string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	  msg += "internal error while treating parameter "+*p12+" (no function associated)";
	  throw(runtime_error(msg));
	}
	usedVariables.clear();
	modifiedVariables.clear();
	// generating temporaries for variables of thoses fields
	for(p14=p13->second.begin();p14!= p13->second.end();++p14){
	  for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();++p15){
	    usedVariables.insert(*p15);	  
	  }
	  for(p15=p14->modifiedVariables.begin();p15!=p14->modifiedVariables.end();++p15){
	    modifiedVariables.insert(*p15);	  
	  }
	}
	for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	  if((p16=usedVariables.find(*p15))!=usedVariables.end()){
	    usedVariables.erase(*p16);
	  }
	}
	// declaring temporaries
	for(p15=usedVariables.begin();p15!=usedVariables.end();++p15){
	  if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	    this->srcFile << "const double tmp_" << *p15 << " = " 
			  << *p15 << ".getValueIJ(*ptr2,1);\n";
	  }
	}
	for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	  if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	    this->srcFile << "double tmp_" << *p15 << " = " << *p15 << ".getValueIJ(*ptr2,1);\n";
	  }
	}
	for(p14=p13->second.begin();p14!= p13->second.end();++p14){
	  if(p14->modifiedVariables.size()==1){
	    this->srcFile << "tmp_" << *(p14->modifiedVariables.begin()) << " = ";
	    this->srcFile << p14->name << "(";
	    for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();){
	      if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
		this->srcFile << "tmp_" << *p15;
	      } else {
		this->srcFile << *p15;
	      }
	      if((++p15)!=p14->usedVariables.end()){
		this->srcFile << ",";
	      }
	    }
	  } else{
	    this->srcFile << "this->" << p14->name << "(";
	    for(p15=p14->modifiedVariables.begin();p15!=p14->modifiedVariables.end();){
	      this->srcFile << "tmp_" << *p15;
	      if((++p15)!=p14->modifiedVariables.end()){
		this->srcFile << ",";
	      }
	    }
	    if(!p14->usedVariables.empty()){
	      this->srcFile << ",";
	    }
	    for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();){
	      if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
		this->srcFile << "tmp_" << *p15;
	      } else {
		this->srcFile << *p15;
	      }
	      if((++p15)!=p14->usedVariables.end()){
		this->srcFile << ",";
	      }
	    }
	  }
	  this->srcFile << ");\n";
	}
	for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	  this->srcFile << *p15 << ".setValueIJ(*ptr2,1,tmp_" << *p15 << ");\n";
	}
	this->srcFile << "}\n";
	++nbr;
      } else if (p->type=="TabString"){
	this->srcFile << "// Calling functions whose domains are defined through parameter " 
		      << *p12 << endl;
	this->srcFile << "for(unsigned int index=0;index!=static_cast<unsigned short>(" << *p12 << ".getTaille());++index){\n";
	this->srcFile << "ptr = this->nodesOfZones.find(this->" << *p12<< "[index]);\n";
	this->srcFile << "if(ptr==this->nodesOfZones.end()){\n";
	this->srcFile << "string msg(\"" << this->className << "::execute : \");\n";
	this->srcFile << "msg += \"internal error (no group named \" + this->" << *p12 << "[index] +\" defined).\";\n";
	this->srcFile << "throw(PleiadesError(msg));\n";
	this->srcFile << "}\n";
	this->srcFile << "const vector<int>& nodes = ptr->second;\n";
	this->srcFile << "for(ptr2=nodes.begin();ptr2!=nodes.end();++ptr2){\n";
	p13 = mfunctionsII.find(*p12);
	if(p13==mfunctionsII.end()){
	  string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	  msg += "internal error while treating parameter "+*p12+" (no function associated)";
	  throw(runtime_error(msg));
	}
	usedVariables.clear();
	modifiedVariables.clear();
	// generating temporaries for variables of thoses fields
	for(p14=p13->second.begin();p14!= p13->second.end();++p14){
	  for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();++p15){
	    usedVariables.insert(*p15);	  
	  }
	  for(p15=p14->modifiedVariables.begin();p15!=p14->modifiedVariables.end();++p15){
	    modifiedVariables.insert(*p15);	  
	  }
	}
	for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	  if((p16=usedVariables.find(*p15))!=usedVariables.end()){
	    usedVariables.erase(*p16);
	  }
	}
	// declaring temporaries
	for(p15=usedVariables.begin();p15!=usedVariables.end();++p15){
	  if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	    this->srcFile << "const double tmp_" << *p15 << " = " 
			  << *p15 << ".getValueIJ(*ptr2,1);\n";
	  }
	}
	for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	  if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	    this->srcFile << "double tmp_" << *p15 << " = " << *p15 << ".getValueIJ(*ptr2,1);\n";
	  }
	}
	for(p14=p13->second.begin();p14!= p13->second.end();++p14){
	  if(p14->modifiedVariables.size()==1){
	    this->srcFile << "tmp_" << *(p14->modifiedVariables.begin()) << " = ";
	    this->srcFile << p14->name << "(";
	    for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();){
	      if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
		this->srcFile << "tmp_" << *p15;
	      } else {
		this->srcFile << *p15;
	      }
	      if((++p15)!=p14->usedVariables.end()){
		this->srcFile << ",";
	      }
	    }
	  } else{
	    this->srcFile << "this->" << p14->name << "(";
	    for(p15=p14->modifiedVariables.begin();p15!=p14->modifiedVariables.end();){
	      this->srcFile << "tmp_" << *p15;
	      if((++p15)!=p14->modifiedVariables.end()){
		this->srcFile << ",";
	      }
	    }
	    if(!p14->usedVariables.empty()){
	      this->srcFile << ",";
	    }
	    for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();){
	      if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
		this->srcFile << "tmp_" << *p15;
	      } else {
		this->srcFile << *p15;
	      }
	      if((++p15)!=p14->usedVariables.end()){
		this->srcFile << ",";
	      }
	    }
	  }
	  if(p14->useTimeIncrement){
	    this->srcFile << ",dt";
	  }
	  this->srcFile << ");\n";
	}
	for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	  this->srcFile << *p15 << ".setValueIJ(*ptr2,1,tmp_" << *p15 << ");\n";
	}
	this->srcFile << "}\n";
	this->srcFile << "} // end of treatment of functions whose domains are defined through parameter "<< *p12 << "\n";
      } else {
	string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	msg += "internal error while treating parameter "+*p12+" (wrong type " + p->type  +")";
	throw(runtime_error(msg));
      }
    }
    // Treating functions whose domains are explicitly given
    for(p12=sdomains.begin();p12!=sdomains.end();++p12,++nbr){
      this->srcFile << "// Calling functions on domain " << *p12 << endl;
      this->srcFile << "for(ptr2=nodes" << nbr << ".begin();";
      this->srcFile << "ptr2!=nodes" << nbr << ".end();++ptr2){\n";
      p13 = mfunctions.find(*p12);
      if(p13==mfunctions.end()){
	string msg("MFrontPleiadesModelParserArchitecture1_4::writeSrcFile : ");
	msg += "internal error while treating domain "+*p12+" (no function associated)";
	throw(runtime_error(msg));
      }
      usedVariables.clear();
      modifiedVariables.clear();
      // generating temporaries for variables of thoses fields
      for(p14=p13->second.begin();p14!= p13->second.end();++p14){
	for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();++p15){
	  usedVariables.insert(*p15);	  
	}
	for(p15=p14->modifiedVariables.begin();p15!=p14->modifiedVariables.end();++p15){
	  modifiedVariables.insert(*p15);	  
	}
      }
      for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	if((p16=usedVariables.find(*p15))!=usedVariables.end()){
	  usedVariables.erase(*p16);
	}
      }
      // declaring temporaries
      for(p15=usedVariables.begin();p15!=usedVariables.end();++p15){
	if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	  this->srcFile << "const double tmp_" << *p15 << " = " << *p15 << ".getValueIJ(*ptr2,1);\n";
	}
      }
      for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	  this->srcFile << "double tmp_" << *p15 << " = " << *p15 << ".getValueIJ(*ptr2,1);\n";
	}
      }
      for(p14=p13->second.begin();p14!= p13->second.end();++p14){
	if(p14->modifiedVariables.size()==1){
	  this->srcFile << "tmp_" << *(p14->modifiedVariables.begin()) << " = ";
	  this->srcFile << p14->name << "(";
	  for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();){
	    if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	      this->srcFile << "tmp_" << *p15;
	    } else {
	      this->srcFile << *p15;
	    }
	    if((++p15)!=p14->usedVariables.end()){
	      this->srcFile << ",";
	    }
	  }
	} else{
	  this->srcFile << "this->" << p14->name << "(";
	  for(p15=p14->modifiedVariables.begin();p15!=p14->modifiedVariables.end();){
	    this->srcFile << "tmp_" << *p15;
	    if((++p15)!=p14->modifiedVariables.end()){
	      this->srcFile << ",";
	    }
	  }
	  if(!p14->usedVariables.empty()){
	    this->srcFile << ",";
	  }
	  for(p15=p14->usedVariables.begin();p15!=p14->usedVariables.end();){
	    if(this->fieldNames.find(*p15)!=this->fieldNames.end()){
	      this->srcFile << "tmp_" << *p15;
	    } else {
	      this->srcFile << *p15;
	    }
	    if((++p15)!=p14->usedVariables.end()){
	      this->srcFile << ",";
	    }
	  }
	}
	if(p14->useTimeIncrement){
	  this->srcFile << ",dt";
	}
	this->srcFile << ");\n";
      }
      for(p15=modifiedVariables.begin();p15!=modifiedVariables.end();++p15){
	this->srcFile << *p15 << ".setValueIJ(*ptr2,1,tmp_" << *p15 << ");\n";
      }
      this->srcFile << "}\n";
    }
    this->srcFile << this->execute;
    this->srcFile << "return true;\n";
    this->srcFile << "} // end of " << this->className << "::execute\n\n";
    
    this->srcFile << "void\n" << this->className 
		  << "::executeInitialPostProcessingTasks(const bool)\n{} // end of " << this->className 
		  << "::executeInitialPostProcessingTasks\n\n";

    this->srcFile << "void\n" << this->className 
		  << "::executePostProcessingTasks(const bool)\n{} // end of " << this->className 
		  << "::executePostProcessingTasks\n\n";

    if(!this->localParameters.empty()){
      this->srcFile << "using Pleiades::PExamplars::TemplateModelClassProxy;\n";
      this->srcFile << "TemplateModelClassProxy<"
		    << this->className
		    << "> proxy" << this->className << "(\""
		    << this->className << "\");\n";
    }
    if(this->hasDefaultConstructor){
      this->srcFile << "GENERATE_PROXY(IModel," << this->className << ");\n\n";
    }
    this->srcFile << "} // end of namespace PModels\n\n";
    this->srcFile << "} // end of namespace PMetier\n\n";
    this->srcFile << "} // end of namespace Pleiades\n";
  } // end of MFrontPleiadesModelParserArchitecture1_4::writeSrcFile(void)

  void
  MFrontPleiadesModelParserArchitecture1_4::writeOutputFiles(void)
  {
    using namespace std;
    if(this->className.empty()){
      string msg("MFrontPleiadesModelParserArchitecture1_4::writeOutputFiles : ");
      msg += "no behaviour name defined.";
      throw(runtime_error(msg));      
    }
    this->headerFileName  = "include/Pleiades/PMetier/PModels/"+this->className;
    this->headerFileName += "-pleiades.hh";
    this->srcFileName  = "src/"+this->className;
    this->srcFileName += "-pleiades.cpp";
    this->openOutputFiles();
    this->generateOutputFiles();
    this->closeOutputFiles();
  } // end of class MFrontPleiadesModelParserArchitecture1_4::writeOutputFiles()

  std::map<std::string,std::vector<std::string> >
  MFrontPleiadesModelParserArchitecture1_4::getGeneratedSources(void)
  {
    using namespace std;
    map<string,vector<string> > src;
    src["libPleiadesMaterialModels"].push_back(this->className+"-pleiades.cpp");
    return src;
  } // end of MFrontPleiadesModelParserArchitecture1_4::getGeneratedSources
  
  std::vector<std::string>
  MFrontPleiadesModelParserArchitecture1_4::getGeneratedIncludes(void)
  {
    using namespace std;
    vector<string> inc;
    inc.push_back("Pleiades/PMetier/PModels/"+this->className+"-pleiades.hh");
    return inc;
  } // end of MFrontPleiadesModelParserArchitecture1_4::getGeneratedIncludes

  std::map<std::string,std::vector<std::string> >
  MFrontPleiadesModelParserArchitecture1_4::getGlobalIncludes(void)
  {
    using namespace std;
    map<string,vector<string> > incs;
    incs["libPleiadesMaterialModels"].push_back("`pleiades-config --includes`\n");
    return incs;
  } // end of MFrontPleiadesModelParserArchitecture1_4::getGlobalIncludes
  
  std::map<std::string,std::vector<std::string> >
  MFrontPleiadesModelParserArchitecture1_4::getGlobalDependencies(void)
  {
    using namespace std;
    map<string,vector<string> > libs;
    libs["libPleiadesMaterialModels"].push_back("`pleiades-config --libs` -lm");
    return libs;
  } // end of MFrontPleiadesModelParserArchitecture1_4::getGlobalDependencies
    
  std::map<std::string,std::vector<std::string> >
  MFrontPleiadesModelParserArchitecture1_4::getLibrariesDependencies(void)
  {
    using namespace std;
    return map<string,vector<string> >();
  } // end of MFrontPleiadesModelParserArchitecture1_4::getLibrariesDependencies

  void
  MFrontPleiadesModelParserArchitecture1_4::writeAssignDefaultValue(const VarContainer::const_iterator p,
								    const std::map<std::string,std::string>::const_iterator p4)
  {
    using namespace std;
    if((p->type=="TabDouble")||(p->type=="TabString")){
      unsigned short i;
      unsigned short size;
      vector<string> res;
      string tmpName;
      istringstream c(p4->second);
      copy(istream_iterator<string>(c),istream_iterator<string>(),back_inserter(res));
      istringstream c2(res.front());
      c2 >> size;
      i=0;
      tmpName="tmp"+p->name;
      while(this->varNames.find(tmpName)!=this->varNames.end()){
	tmpName="tmp"+p->name+toString(i);
	++i;
      }
      this->srcFile << p->type << " " << tmpName << "(" << size << ");\n";
      for(i=0;i!=size;++i){
	this->srcFile << tmpName << "[" << i << "] = " << res.at(i+1) << ";" << endl;
      }
      this->srcFile << "this->" << p->name << " = " << tmpName << ";" << endl;
    } else if((p->type=="string")||(p->type=="double")||(p->type=="real")){
      this->srcFile << "this->" << p->name << " = "  << p4->second << ";" << endl;
    } else {
      string msg("MFrontPleiadesModelParserArchitecture1_4::writeAssignDefaultValue : ");
      msg+="type "+p->type+" is not supported.\n";
      throw(runtime_error(msg));
    }   
  } // end of MFrontPleiadesModelParserArchitecture1_4::writeAssignDefaultValue

//   struct MFrontPleiadesModelParserArchitecture1_4::LoadingVariable
//   {
//     std::string    name;
//     std::string    tabName;
//     unsigned short lineNumber;
//     unsigned short depth;
//   }; // end of struct MFrontPleiadesModelParserArchitecture1_4::LoadingVariable

//   void
//   MFrontPleiadesModelParserArchitecture1_4::treatLoadingVariable(void)
//   {
//     using namespace std;
//     LoadingVariable var;
//     var.depth = 0u;
//     string tabName;
//     bool endOfTreatement=false;
//     while((this->current!=this->fileTokens.end())&&
// 	  (!endOfTreatement)){
//       if(!isValidIdentifier(this->current->value)){
// 	this->throwRuntimeError("MFrontPleiadesModelParserArchitecture1_4::treatLoadingVariable",
// 				"Variable given is not valid (read '"+this->current->value+"'.");
//       }
//       var.name = this->current->value;
//       var.lineNumber = this->current->line;
//       ++(this->current);
//       this->checkNotEndOfFile("MFrontPleiadesModelParserArchitecture1_4::treatLoadingVariable");
//       if(this->current->value==","){
// 	++(this->current);
//       } else if (this->current->value==";"){
// 	endOfTreatement=true;
// 	++(this->current);
//       } else {
// 	this->throwRuntimeError("MFrontPleiadesModelParserArchitecture1_4::treatLoadingVariable",
// 				"',' or ';' expected after '"+var.name+"'");
//       }
//       this->registerVariable(var.name);
//       var.tabName = var.name;
//       var.tabName[0] = static_cast<char>(toupper(var.tabName[0]));
//       var.tabName = "tab"+var.tabName;
//       this->registerVariable(tabName);
//       this->loadingVariables.push_back(var);
//     }
//     if(!endOfTreatement){
//       --(this->current);
//       this->throwRuntimeError("MFrontPleiadesModelParserArchitecture1_4::treatLoadingVariable",
// 			      "expected ';' before end of file.");
//     }
//   } // end of MFrontPleiadesModelParserArchitecture1_4::treatLoadingVariable

} // end of namespace mfront  
