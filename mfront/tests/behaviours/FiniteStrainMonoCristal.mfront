/*!
 * \file   FiniteMonocristal.mfront
 * \brief  
 * \author Jean-Michel Proix - Helfer Thomas
 * \date   20 mars 2014
 */

@Parser    ImplicitFiniteStrain;
@Behaviour FiniteStrainMonoCristal;
@Author JMP;
@Description{
  "Test d'implantation d'une loi "
  "monocristalline en grandes déformations"
}

@ModellingHypothesis Tridimensional;
@OrthotropicBehaviour;
@RequireStiffnessTensor;

@Algorithm NewtonRaphson_NumericalJacobian;
@Theta 1.;
@Epsilon 1.e-9;

@StateVariable StrainStensor eel;
eel.setGlossaryName("GreenLagrangeStrain");

@StateVariable strain g[12];

// Mandel stress tensor
@LocalVariable StressStensor M;
// multiplicative increment fo the deformation gradient
@LocalVariable Tensor dF;
// deformation gradient relative to the plastic configuration at the
// beginning of the time step
@LocalVariable Tensor Fp0;
// a temporary variable
@LocalVariable Tensor dF_Fe0;

@AuxiliaryStateVariable Tensor Fe;
@AuxiliaryStateVariable real p[12];
@AuxiliaryStateVariable real a[12];

@Includes{
#include"TFEL/Math/General/CubicRoots.hxx"
#include"TFEL/Material/MetallicCFCSlidingSystems.hxx"
#include"TFEL/Material/MetallicCFCGenericSlidingSystemsInteractionMatrix.hxx"
}

@Members{
  // Mono cristal gliding system
  typedef MetallicCFCSlidingSystems<real> SlidingSystems;
  // Interaction matrix
  typedef MetallicCFCGenericSlidingSystemsInteractionMatrix<real> InteractionMatrix;
  // number of sliding systems
  static const unsigned short Nss = SlidingSystems::Nss;
}

//! interaction matrix
@LocalVariable tfel::math::tmatrix<12,12,real> mh;

@Parameter h1 = 1.  ;
@Parameter h2 = 1.  ;
@Parameter h3 = 0.6 ;
@Parameter h4 = 12.3;
@Parameter h5 = 1.6 ;
@Parameter h6 = 1.8 ;

@MaterialProperty real m;
@MaterialProperty real K;
@MaterialProperty real C;
@MaterialProperty real R0;
@MaterialProperty real Q;
@MaterialProperty real b;
@MaterialProperty real d1;

@InitLocalVariables{
  dF  = F1*invert(F0);
  Fp0 = invert(Fe)*F0;
  dF_Fe0 = dF*Fe;
  // la matrice d'interaction construite une fois pour toute
  mh = InteractionMatrix::getInteractionMatrix(h1,h2,h3,
					       h4,h5,h6);
} // end of @InitLocalVars


@ComputeStress{
  // second piola-kirchhoff stress tensor
  const StressStensor S = D*eel;
  // Mandel stress tensor
  StrainStensor tmp(StrainStensor::Id() + 2*eel);
  M  = tmp*S;
}

@Integrator{
  const SlidingSystems& ss = SlidingSystems::getSlidingSystems();
  Tensor inv_dFp = Tensor::Id();
  for(unsigned short i=0;i!=12;++i){
    inv_dFp -= dg[i]*ss.mu[i];
  }
  real J_inv_dFp = det(inv_dFp);
  inv_dFp /= CubicRoots::cbrt(J_inv_dFp);
  // Fe en fin de pas de temps
  Fe  = dF_Fe0*inv_dFp;
  // équation associée à l'incrément de déformation élastique
  feel = eel+deel-computeGreenLagrangeTensor(Fe);
  // increment de déformation plastique
  real vp[Nss];
  real ag[Nss];
  real pe[Nss];
  for(unsigned short i=0;i!=Nss;++i){
    ag[i] = abs(dg[i]);
    pe[i] = Q*(1.-exp(-b*(p[i]+theta*ag[i]))) ;
  }
  for(unsigned short i=0;i!=Nss;++i){
    real Rp = R0;
    for(unsigned short j=0;j!=Nss;++j){
      Rp += mh(i,j)*pe[j] ;
    }
    const real tau = syme(ss.mu[i]) | M ;
    const real va  = (dg[i]-d1*a[i]*ag[i])/(1.+d1*theta*ag[i]);
    const real tma = tau-C*(a[i]+theta*va) ;
    const real tmR = abs(tma)-Rp;
    if (tmR>0.){
      if(tmR>1.2*K){
	return false;
      }
      real sgn=tma/abs(tma);
      vp[i]  = dt*sgn*pow((tmR/K),m);
    } else{
      vp[i]=0.;
    }
    fg[i]  -= vp[i];
  }
} // end of @Integrator


@ComputeFinalStress{
  const SlidingSystems& ss = SlidingSystems::getSlidingSystems();
  // approximation de l'inverse de \(\Delta\,F_p\)
  Tensor inv_dFp = Tensor::Id();
  for(unsigned short i=0;i!=12;++i){
    inv_dFp -= dg[i]*ss.mu[i];
  }
  real J_inv_dFp = det(inv_dFp);
  inv_dFp /= CubicRoots::cbrt(J_inv_dFp);
  // Fe en fin de pas de temps
  Fe  = dF_Fe0*inv_dFp;
  // Piola-Kirchhoff II
  StressStensor S   = D*eel;
  // Cauchy
  sig = convertSecondPiolaKirchhoffStressToCauchyStress(S,Fe);
}

@UpdateAuxiliaryStateVars{
  for(unsigned short i=0;i!=Nss;++i){
    p[i]+=abs(dg[i]);
    a[i]+=(dg[i]-d1*a[i]*abs(dg[i]))/(1.+d1*abs(dg[i]));
  }
}

